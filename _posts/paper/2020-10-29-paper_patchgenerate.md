---
title: "Using Safety Properties to Generate Vulnerability Patches"
subtitle: "S&P2019 | 补丁生成"
layout: post
author: "Veronica"
header-style: text
tags:
  - paper
  - 补丁生成
  - 程序分析
---

#### Abstract & Introduction

**以往ARP的缺陷**：许多现有的ARP(automatic program repair)方法都无法实现是因为它们使用测试用例来近似得到属性，从而导致补丁无法完全修复漏洞，甚至可能引入新的错误。大多数现有的ARP工具依赖于一组正/负输入示例来找到一个补丁，使程序在这些示例上正确运行。工具检查补丁程序是否满足正示例输入，在负示例输入上报错。然而，通常很难获得所有完整的示例输入集，并且补丁程序可能在其他输入上不能正常运行，或者补丁修复的漏洞在给定其他输入的时候仍然可以被利用。

**论文提出的ARP：**为了解决这些问题，论文提出了Senx，它给出一组安全属性和可以触发漏洞的单个输入，检测漏洞输入违反的安全属性，并生成相应的补丁来加强安全属性，从而消除漏洞。论文的评估表明,生成的补丁Senx在11个应用程序的 42个真实漏洞中成功修复了32个。

本文提出的Property-based APR。基于属性的方法的优点是：可以一次性指定一小组安全属性，并在大量程序上使用，而不需要指定关于每个程序的任何具体内容，或者收集一组全面的测试用例。

与基于示例的APR相比，基于属性的APR产生的补丁对所有可能的输入都有效。基于属性的APR以一个特定的漏洞(例如，一个缓冲区溢出漏洞)为输入，并生成一个针对该漏洞的补丁。

<!--安全属性必须将它们映射到程序中的变量上，以生成源代码补丁。但是有时候不是所有的与安全属性相关的变量都是可用的。例如，缓冲区的大小可以存储在一个变量中，该变量只能在分配缓冲区的函数中使用，而不能在访问缓冲区的函数中使用。这需要一个程序分析，该程序分析能够为这些安全属性生成等价的表达式，并选择程序中相交的set。-->

安全属性需要映射到程序变量和常量或者函数调用上，来生成源码补丁。<!--一个APR工具需要检查一个函数是否有side-effect，甚至可能需要在一个程序中生成新的函数来计算需要的值，而不引入不想要的side-effect。-->

许多漏洞依赖于循环迭代的次数。如果检查每个循环迭代的安全属性, 会导致性能开销。为了减少生成补丁对性能的影响，APR工具应该对循环生成一个补丁，在循环之外检查安全属性，以避免性能开销。

##### contributions

1. 描述了如何在Senx中指定安全属性，并演示了缓冲区溢出、恶意转换和整数溢出漏洞的三个安全属性示例。
2. 描述了Senx的设计，这是一个基于属性的自动补丁生成系统，它使用了新的程序分析技术:表达式转换、循环克隆和访问范围分析。



#### Motivation

##### Example-based approaches

这种方法会导致两个问题。首先，生成的约束通常只捕获基于测试用例中使用的具体值的约束，而不是程序变量之间关系的约束。为了说明这一点，表I列出了使用此类工具所需的典型测试输入，我们认为这些工具可能用于清单1中的示例。

<img src="https://i.loli.net/2020/10/30/gaLSPz1VR5sotTO.png" style="zoom:50%;" />

<img src="https://i.loli.net/2020/10/30/z7vpdjyFk8iTs51.png" style="zoom:50%;" />

 给定这些测试用例，SemFix和Angelix会发现值为1或2的argv[1]与负测试用例不相关，因为它们在正测试用例和负测试用例中都具有这些值。这样，它就会错误地推断出strlen(argv[2]) < 3需要添加到代码中才能正确。由于测试用例套件中没有包含strlen(argv[2]) > 2的阳性测试用例，所以生成了错误的补丁。这说明了基于示例的系统的缺点，因为它们很容易成为测试套件中缺少用例的牺牲品，这是出了名的难以完成的。

##### Property-based approaches

AutoPaG只处理一种类型的漏洞，即缓冲区溢出，因此它不需要识别漏洞的类型来执行适当的安全属性——如果漏洞是缓冲区溢出以外的任何类型，它都无法生成正确的补丁。此外，如果需要执行安全属性的位置不在漏洞发生的同一功能范围内，AutoPaG无法生成补丁。在我们的示例中，缓冲区溢出发生在rev函数中，但是补丁必须位于main中的位置。

最后，AutoPaG通过在运行时对代码进行修改来加强其安全性。在清单1中，AutoPaG将在第8行检测和检查for循环内的缓冲区大小，从而导致性能开销。相反，Senx通过分析循环边界象征性地提取循环访问的内存范围，允许它检查循环之外的安全属性。



#### Problem Definition

##### A. Patch

为了生成补丁，Senx需要输入可以触发目标漏洞的输入。
通常，这是可以从poc中获取的输入类型，或者是可能导致程序崩溃的fuzzer生成的输入类型。
由此，Senx生成了一个补丁，以确保其支持的所有安全属性都保持不变，其中每个安全属性对应于特定类型的漏洞。 
Senx构建补丁可以采用以下两种形式之一：a）检测安全属性是否不再有效，如果存在，则会引发错误，以使程序执行远离漏洞所在的路径；b）防止违反安全属性。

##### B. Safety Properties

每个安全属性对应于一个漏洞类型，是一个抽象的布尔表达式，当映射到程序中的具体变量时，可以对其进行评估。我们描述了Senx目前支持的三种类型的安全属性：缓冲区溢出，错误类型转换和整数溢出.



#### Design

##### A. Overview

Senx通过四个不同的步骤生成补丁：漏洞识别，谓词生成，补丁放置和补丁合成，如图1所示。

<img src="https://i.loli.net/2020/10/30/RCspUNPiyGjA3gz.png" alt="image-20201029231952520" style="zoom:50%;" />

首先，在漏洞识别过程中，Senx接收程序和可以触发漏洞的输入，并输出违反安全性的属性，程序中的漏洞以及执行跟踪的源代码表达式。 谓词生成将上一步中标识的安全属性映射到程序源代码中变量和函数调用上的具体表达式。在修补程序放置期间，Senx使用在漏洞标识中找到的漏洞点和在谓词生成中产生的谓词来查找要插入补丁的程序位置。最后，在补丁合成中，Senx获取补丁位置和实例化谓词以生成补丁代码。

##### B. Vulnerability Identification

Senx使用LLVM IR指令以漏洞触发输入执行程序，直到违反安全属性为止。它将此点标记为漏洞点。

此阶段的主要输出是漏洞点，违反的安全属性以及一组符号表达式，它们表示已执行程序中变量的符号值。

论文修改了KLEE的LLVM IR执行引擎，以提取保留足够信息的表达式，以便轻松将其转换回源代码。将源代码符号名称与LLVM IR指令一起存储。

Senx还通过支持复杂数据类型（例如C / C ++结构）扩展了KLEE，从而可以将符号表达式转换回源代码语法以生成补丁。

##### C. Predicate Generation

谓词生成的目的是获取上一阶段中标识的违反安全属性的抽象布尔表达式，并将其映射到程序源代码中的具体表达式。

**对于整型溢出：**在第一种情况下，程序将溢出操作的结果分配给一个变量，该变量的大小大于操作的大小（例如，将溢出32位乘法的结果分配给64位变量）。在这种情况下，Senx会通过修改操作类型来生成修复补丁，以免发生溢出（例如，将32位乘法更改为64位乘法）。在第二种情况下，没有这样的分配。因此，Senx生成一个检查和错误谓词，以检查结果是否小于预期（例如，加法的结果是否小于其输入的任何一个）。

**对于强制类型转换：**$(mem\_access > buffer\_upper||mem\_access < buffer\_lower)$

**对于缓冲区溢出：**$(mem\_access\_upper > buffer\_upper || mem\_access\_lower < buffer\_lower)$

对于Loop:

ARA(Access relation analysis): 使用算法1中描述的算法对嵌套循环进行访问范围分析。它对循环进行分析，在函数F中封闭内存访问指令inst，从最内层的循环开始，迭代到最外层的循环，累加和减少循环归纳变量，包括inst使用的指针。

Loop cloning: 访问范围分析不能应用于LLVM无法规范化的循环。对于这些循环，Senx使用循环克隆。Senx应用循环克隆来生成新的代码，该代码保留了循环迭代的次数，但是删除了会引起副作用的代码。然后可以使用新代码安全地返回所生成补丁中的访问范围



