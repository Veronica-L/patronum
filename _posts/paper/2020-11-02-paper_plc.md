---
title: "Towards Automated Safety Vetting of PLC Code in Real-World Plants"
subtitle: "S&P2019 | PLC审查"
layout: post
author: "Veronica"
header-style: text
tags:
  - paper
  - PLC安全审查
  - 程序分析
---



##### Abstract & Introduction

可编程逻辑控制器(PLCs)中的安全违规，无论是由故障或攻击引起的，最近已经引起了极大的关注。然而，以前在PLC代码审查方面的努力存在许多缺陷。静态分析和验证会导致严重的误报，并且不能揭示特定的运行时上下文。另一方面，动态分析和符号执行之所以失败，是因为它们无法处理真实的事件驱动和定时敏感的PLC程序。

在本文中，我们提出了VETPLC，一种时间上下文感知，基于程序分析的方法，以产生可用于自动安全审查的定时事件序列。为此，我们(a)进行静态程序分析，创建定时事件因果图，以了解PLC代码中事件之间的因果关系。和(b)从工业控制系统(ICS)测试床收集的数据轨迹中挖掘时间不变量，以定量测量受机器操作约束的时间依赖性。

我们的VETPLC原型已经在15K行代码中实现。我们从两个不同的ICS设置中对10个真实场景进行评估。我们的实验表明，VETPLC优于最先进的技术，可以生成事件序列，用于自动检测安全隐患。

因此，有必要检测可能发生这种违反安全的情况。由于当代集成电路的复杂性，涉及到plc和其他各种机器之间的交互，我们需要自动化的机制来发现这些问题。

虽然存在等旨在静态验证PLC逻辑的工作，但这些静态分析技术由于无法推断运行时执行上下文，存在严重的误报。例如，它们可以检测代码中运行时不可行的潜在问题路径。此外，ICS的行为在运行时受到严格的物理限制(例如速度、温度等)以及这些属性的变化。为了解决这些限制，之前的工作[35]，[39]，[45]，[62]已经探索了使用动态模拟运行时行为来检测PLC安全违反。另外，最近的工作[43]，[54]已经启用了PLC代码的符号执行。**尽管这些技术在查找独立PLC程序中的bug方面效果明显，但它们的局限性在于它们忽略了一个重要的事实，即现实中的PLC永远不会单独工作。**相反，它与工厂车间的其他可编程组件(如机器人、cnc甚至其他plc)协作，以执行某些任务。因此，PLC的逻辑不仅由内部数据输入触发，而且由于多单元之间的协调和通信，还由外部事件驱动。不幸的是，**前面提到的工作主要关注于输入值的测试或解决，而不是多个协作组件的完整事件空间，因此不能自动运行真实的PLC程序**。

为了解决这个问题，我们提出了VETPLC，一个时间上下文感知，基于程序分析的系统，它可以自动构造定时事件序列。这些序列可以使PLC代码的自动动态安全审查成为可能。

因此，VETPLC补充了之前在动态分析和符号执行方面的研究，即只搜索PLC代码中的值空间。它进一步介绍了探索时间事件空间的新技术，以有效地锻炼和检查PLC程序。

Contributions:

我们探索物理ICS测试床以获得一个重要的见解:真实的控制器代码是事件驱动的时间敏感型。
•我们是第一个自动动态安全检查真实世界的PLC代码通过创建定时事件序列。
•我们使用自定义静态分析，解决具体的plc的编程范例，以提取事件之间的因果关系。
•据我们所知，这是第一个工作在物理ICS测试床中提取时间依赖性。
•我们已经证明了VETPLC在两种不同类型的真实世界ICS测试床上的有效性:VETPLC在真实世界测试床上发现了“有机”漏洞。

PLC：

PLC是许多现代自动化系统的核心控制单元。它既可以作为一个独立的主控制器使用，也可以作为一个从控制器集成到其他机器，如CNCs。PLC的基本功能是**根据输入信号和内部控制逻辑反复生成控制命令**。在启动时，PLC在一个无限循环中运行，其中每个循环称为扫描周期，包括三个主要阶段。1)输入:PLC从外部事件(如传感器)读取输入，并在内存中缓冲。2)计算:所有的变量值都是固定的。然后PLC调用它的逻辑程序和计算新的可变状态基于缓冲的输入和他们的当前状态。3)输出:PLC将计算出的新状态写入输出存储器，以便开始下一个循环。

PLC编程语言遵循国际标准IEC 61131-[10]。它定义了三种图形语言和两种文本语言。所有的语言都共享iec61131 -3的通用元素，并且可以在每一种语言之间翻译。特别是，结构化文本(ST)是一种高级文本语言，在语法上类似于Pascal(图2)，因此以其可理解性[20]而闻名。但是请注意，尽管ST程序类似于用其他高级语言编写的程序，但是由于存在扫描周期，它的数据流非常不同。由于PLC变量在计算阶段保持完整，**由逻辑代码引起的值变化直到下一个周期才会生效**。实际上，在任何扫描周期中，一个PLC变量有两个“版本”:上一个周期的“当前”版本在当前时间有效;“新”版本记录当前轮中的所有更改，并最终在输出阶段替换“当前”的更改。因此，1)扫描周期内不存在数据流;2)数据流发生在相邻的两个周期之间，变量的“current”值可能是上一个周期中任何赋值指令的结果。



工业机器人：

各个供应商的机器人编程语言都是专有的，但通常分为两种类型:高级和低级。高级语言，如用于FANUC机器人的KAREL或用于ABB的RAPID，都受到Pascal语法的影响。底层代码类似于程序集，通过直接连接到机器人的手持设备teach pendants来开发。除了常见的程序指令(例如，赋值、条件或无条件跳跃和函数调用)，这些程序都使用特殊的运动指令来指导物理运动，并使用等待指令来启用延迟和控制时间。虽然机器人程序可以通过主函数启动，但实际上它们是**由输入事件动态触发的**。为了不丧失一般性，我们以后将基于FANUC的拾取和放置机器人的简单机器人内部工作原理，它拥有世界上安装最多的工业机器人[56]。具体来说，我们关注的是它的teach pendant (TP)语言，如图8所示，它是FANUC机器人编程的事实上的标准



跨设备通信：

PLC和远程设备通过工业网络协议(如以太网/IP[8])进行信号通信。远程设备为输入和输出打开多个引脚。例如，FANUC机器人可以支持512位数字输入(DI)和512位数字输出(DO)。在PLC端，每个远程引脚被映射为一个基址(即IP地址)加上一个偏移量。因此，PLC代码可以通过直接访问这些映射的I/O位来控制远程设备。当远程设备被添加到由PLC监督的ICS环境中时，将自动配置I/O映射。一旦它的IP地址被确定，底层以太网/IP协议负责识别这个设备上的I/Os，并将它们绑定到PLC变量。



Example

我们使用智能试验台[47]来激发我们的问题，如图1所示。这个试验台代表了生产模型汽车的全功能装配线。它由一台龙门吊、一条环形输送带、2台取放机器人、3台数控机床组成，并由一台PLC控制。特别地，它配备了Allen Bradley PLC
罗克韦尔自动化公司和发那科机器人公司。值得注意的是，智能试验台是真实汽车制造业的一个缩影。经过20多年的建设和不断的改造，几十年来被无数项目使用。

图2和图8分别部分显示了1单元中PLC和机器人1的控制逻辑。代码片段描述了一个被加工的零件是如何从CNC传递到输送机的。由于一个未加工的部分已经由机架交付到CNC进行加工，PLC代码(图2)现在期望接收加工的部分，并使用空托盘将其交付到下一个单元。通过事件来实现PLC与机器人之间的协调。为了接收和发送这些信号，需要声明6个输入变量(ln.3-7,52)， 2个输出变量(ln.8-9)和4个内部变量(ln.11-13,49)。在每个扫描周期中，PLC首先在初始化期间清除输出变量(Ln.16-19)，然后依次检查所有输入变量以更新输出(Ln.21-44)。更具体地说，ln21-23首先通过检查是否有托盘(托盘传感器)以及是否有部件(非部件传感器)来更新1单元(托盘到达)的空托盘的可用性。然而，如果一个进入托盘已经装载了一部分(ln25 -27)， PLC将发送一个信号通过缩回挡板，让这个托盘通过。当一个空托盘到达单元1时，PLC代码(Ln.29-34)将进一步检查布尔输入，CNC零件就绪，机器人就绪和不(Part - at输送机)，以确认被加工零件的存在，机器人的可用性和输送机上零件的间隙。如果所有条件都满足，PLC将会执行两个动作:1)请求机器人将被加工的零件传递到托盘上，2)更新零件上的制造工艺号。因此启用了两个信号: Deliver Part and Update Part Process。

 Deliver Part: 根据配置，变量交付部分映射到机器人一侧的数字输入(DI[0])。为真，此信号触发图8中的机器人程序执行。然后机器人代码操作机器人手臂，通过一系列运动指令，如直线运动“L”或关节运动“J”，从数控机床上拿起一个零件(图8磅6-12)，并将其传递给输送机(图8磅18-20)。当零件被送到传送带时，机器人打开输出信号DO[2] 0.5秒，表示完成(图8 lb .22-24)。这个输出然后映射到PLC上的部分at输送带。最后，机器人回到了安全地带。

Update Part Process:

![image-20201102193720225](/Users/veronica/Library/Application Support/typora-user-images/image-20201102193720225.png)

<img src="/Users/veronica/Library/Application Support/typora-user-images/image-20201102200405424.png" alt="image-20201102200405424" style="zoom:50%;" />

检测的问题：由于缺少运行时约束，静态分析可能会导致严重的误报，因此不能轻松地解决这个问题。例如，静态分析检测到的一个潜在的错误状态，可能只有当机器人的速度大于10m/s时才会触发，但在实际操作中是无法达到的。相反，动态分析和符号执行不会导致误报。为了在事件驱动程序中使用它们，之前的工作对不同顺序的事件序列进行编码和探索路径。

在我们的例子中,你可以创建一个事件序列的顺序1:Pallet Sensor 􏰉 2:¬ Part Sensor 􏰉 3:CNC Part Ready 􏰉 4:Robot Ready 􏰉 5:¬ Part AtConveyor 􏰉 6:Update Complete 􏰉 7:Part AtConveyor,,如图3所示。注意，最终部分Part AtConveyor终止机器人的逻辑。

使用此序列执行PLC代码不会导致任何错误。然后可以通过切换6:Update Complete 和 7:Part AtConveyor输送带来排列事件(图3b)。然后，安全问题将在运行时发生。然而，仅仅重新安排事件顺序并不能解决时间约束控制器程序中的路径发现问题。例如，图3c中的事件顺序与图3b中的事件顺序相同，但不会导致错误。为了解决这个问题，我们希望通过同时考虑事件的顺序和时间，自动生成有效的、触发错误的事件序列(如图3b)。请注意，另一种方法是将内部超时建模为外部事件，然后在不考虑计时的情况下执行事件排列。

<img src="/Users/veronica/Library/Application Support/typora-user-images/image-20201102201120465.png" alt="image-20201102201120465" style="zoom:50%;" />

为了实现我们的目标，我们开发了VETPLC，它包括三个主要步骤。图4说明了它的体系结构。我们希望部署VETPLC作为一个审查工具，在任何PLC代码发布到生产系统之前检查它。

<img src="/Users/veronica/Library/Application Support/typora-user-images/image-20201102201858879.png" alt="image-20201102201858879" style="zoom:50%;" />

生成事件因果图。给定PLC和机器人代码，我们首先执行静态程序分析来提取互联设备的事件因果关系图。我们进一步利用指定的I/O映射来处理跨设备通信。

挖掘时态不变量。接下来，为了理解那些不能被程序代码揭示的定量时间关系，我们从物理ICS测试床上收集PLC变量的运行时数据踪迹。然后，我们检查跟踪来推断特定事件的发生，并进行数据挖掘来发现时间事件不变量。

自动安全审查与定时事件事件。在生成的时间事件因果图的约束下，我们执行事件排列来自动生成时间事件序列。然后，将生成的序列应用于运动PLC代码进行动态分析。为了自动识别安全问题，我们根据ex- pert知识将工艺安全规范形式化，以便执行运行时验证。



为了解释事件排序的内部约束，我们从PLC和机器人代码中提取事件之间的因果关系和时间关系，生成依赖图。特别地，我们使用时间事件因果关系图(TECGs)来描述跨设备的事件依赖关系。在较高的层次上，一个TECG是基于和或图[53]，它可以说明事件之间的因果关系并表达它们的和/或关系。一个正式的定义如下。

定义1。定时事件因果关系图是一个有向图G = (V, E,α,β)的一组事件Σ时间T和一组时间,地点:

标签功能α:V→Σ将节点与相应事件的标签,每个标签组成的3要素:事件名称、类和持续时间。

我们考虑了6类事件，包括PLC的输入(P IN)、输出(P OUT)、本地(P local)事件和远程设备的事件(R IN、R OUT、R local)。事件持续时间是永久的(P)，这意味着它总是被启用直到被PLC逻辑关闭，或者是有限的时间。

<img src="/Users/veronica/Library/Application Support/typora-user-images/image-20201102203741387.png" alt="image-20201102203741387" style="zoom:50%;" />